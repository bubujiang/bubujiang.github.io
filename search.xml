<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构与算法-表、栈、队列</title>
      <link href="2021/02/18/dsa-tsq/"/>
      <url>2021/02/18/dsa-tsq/</url>
      
        <content type="html"><![CDATA[<h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><blockquote><p>表可以用数组来实现，但数组的效率低下(如在表头插入，要移动整个表的数据)。</p></blockquote><ul><li>单向链表</li><li>双向链表</li><li>循环链表</li></ul><p>&nbsp;</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>又称为LIFO(后进先出)表。只有进栈和出栈，全部都在栈顶操作。<br>&nbsp;</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>又称为FIFO表。像一个管道，从表的末端入队，从表的开头出队。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-基础</title>
      <link href="2021/02/17/dsa-base/"/>
      <url>2021/02/17/dsa-base/</url>
      
        <content type="html"><![CDATA[<h1 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h1><h2 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h2><p>$$<br>a^n * a^m = a^{m+n}<br>$$<br>$$<br>a^n / a^m = a^{n-m}<br>$$<br>$$<br>(ab)^n = a^nb^n<br>$$<br>$$<br>(a^n)^m = a^{nm}<br>$$</p><h2 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h2><blockquote><p>计算机科学中，默认所有的对数都是以2为底的。</p></blockquote><p>$$log_xAB = log_xA + log_xB$$<br>$$log_AB = \frac{log_xA}{log_xB}$$<br>$$log_xA/B = log_xA - log_xB$$<br>$$log_x(A^B) = B \quad log_xA$$</p><h2 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h2><p>$$\sum_{i=0}^NA^i = \frac{A^{N+1} - 1}{A - 1}$$</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><ol><li><strong>基准情形</strong><br>必须有基准情形，无需递归就能解出。</li><li><strong>不断推进</strong><br>不断朝基准情形推进。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql隔离级别</title>
      <link href="2020/07/01/mysql-isolation/"/>
      <url>2020/07/01/mysql-isolation/</url>
      
        <content type="html"><![CDATA[<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><blockquote><p>显示当前隔离级别<br><code>show variables like &#39;transaction_isolation&#39;;</code><br>显示正在运行的事务数量<br><code>select * from information_schema.innodb_trx;</code></p></blockquote><h2 id="数据库常见问题"><a href="#数据库常见问题" class="headerlink" title="数据库常见问题"></a>数据库常见问题</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>读到了其他事务未提交的数据，可能最终不会存到数据库中。</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>当前事务会读取到当前事务外新添加的数据。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>当前事务会读取到当前事务外新修改的数据。</p><h2 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h2><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>可以读取到别的事务没有提交的数据，会出现脏读、幻读、不可重复读</p><h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><p>只能读取到别的事务已经提交的数据，会出现幻读和不可重复读</p><h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>可能会出现幻读，mysql默认隔离级别</p><h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>抛弃并发性能，不会出现脏读、幻读、不可重复读</p><hr><h1 id="试验"><a href="#试验" class="headerlink" title="试验"></a>试验</h1><blockquote><p>假设有数据age为1</p></blockquote><ol><li>同时开启两个事务，事务A和事务B</li><li>事务A修改age为10，然后提交</li><li>在事务B内，select age仍然为显示为1(可重复读)</li><li>此时在事务B内执行 update age+1</li><li>在事务B内，select age显示为11(当前事务内的更新，可以读到. mvvc)</li></ol><hr><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="实现可重复读"><a href="#实现可重复读" class="headerlink" title="实现可重复读"></a>实现可重复读</h2><p>MySQL采用了MVVC(多版本并发控制)的方式。</p><p>数据库表中看到的一行记录可能实际上有多个版本，<br>每个版本的记录除了有数据本身外，还要有一个表示版本的字段，记为 row trx_id，<br>而这个字段就是事务的id，事务id记为 transaction id，<br>它在事务开始的时候向事务系统申请，按时间先后顺序递增。</p><p>快照，可重复读是在事务开始的时候生成一个当前事务全局性的快照，而读提交则是每次执行语句的时候都重新生成一次快照。</p><p>对于一个快照来说，它能够读到：</p><ol><li>当前事务内的更新，可以读到；</li><li>版本(别的事务)未提交，不能读到；</li><li>版本(别的事务)已提交，但是却在快照(当前事务)创建后提交的，不能读到；</li><li>版本(别的事务)已提交，且是在快照(当前事务)创建前提交的，可以读到；</li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 事务 </tag>
            
            <tag> 隔离级别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang调度模型(二)</title>
      <link href="2020/06/15/golang-schedeler-2/"/>
      <url>2020/06/15/golang-schedeler-2/</url>
      
        <content type="html"><![CDATA[<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><blockquote><p>GODEBUG=schedtrace=1000,scheddetail=1 ./example</p></blockquote><h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><blockquote><p>SCHED 0ms: gomaxprocs=4 idleprocs=3 threads=3 spinningthreads=0 idlethreads=0 runqueue=0 gcwaiting=0 nmidlelocked=0 stopwait=0 sysmonwait=0<br>P0: status=1 schedtick=0 syscalltick=0 m=0 runqsize=0 gfreecnt=0<br>M0: p=0 curg=1 mallocing=0 throwing=0 preemptoff= locks=2 dying=0 helpgc=0 spinning=false blocked=false lockedg=1<br>G1: status=2(stack growth) m=0 lockedm=0</p></blockquote><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><ul><li>status：G 的运行状态。</li><li>m：隶属哪一个 M。</li><li>lockedm：锁定 M,如果有锁定,会和m值一样</li></ul><h3 id="G的状态"><a href="#G的状态" class="headerlink" title="G的状态"></a>G的状态</h3><blockquote><p>_Gidle            0    刚刚被分配，还没有进行初始化。<br>_Grunnable        1    已经在运行队列中，还没有执行用户代码。<br>_Grunning         2    不在运行队列里中，已经可以执行用户代码，此时已经分配了 M 和 P。<br>_Gsyscall         3    正在执行系统调用，此时分配了 M。<br>_Gwaiting         4    在运行时被阻止，没有执行用户代码，也不在运行队列中，此时它正在某处阻塞等待中。<br>_Gmoribund_unused    5    尚未使用，但是在 gdb 中进行了硬编码。<br>_Gdead            6    尚未使用，这个状态可能是刚退出或是刚被初始化，此时它并没有执行用户代码，也有可能没有分配堆栈。<br>_Genqueue_unused    7    尚未使用。<br>_Gcopystack        8    正在复制堆栈，并没有执行用户代码，也不在运行队列中。</p></blockquote><h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><ul><li>p：隶属哪一个P.</li><li>curg：当前正在使用哪个G。</li><li>runqsize：运行队列中的G数量。</li><li>gfreecnt：可用的G（状态为 Gdead）。</li><li>mallocing：是否正在分配内存。</li><li>throwing：是否抛出异常。</li><li>preemptoff：不等于空字符串的话，保持 curg 在这个 m 上运行。</li><li>locks: 表示该M是否被锁的状态，M被锁的状态下该M无法执行gc</li><li>spinning: 是否是自旋线程</li><li>blocked: 是否被阻塞</li><li>lockedg: 锁定g在当前m上执行，而不会切换到其他m，一般cgo调用或者手动调用LockOSThread()才会有值</li></ul><h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><ul><li>status：P 的运行状态。</li><li>schedtick：P 的调度次数。</li><li>syscalltick：P 的系统调用次数。</li><li>m：隶属哪一个 M。</li><li>runqsize：运行队列中的 G 数量。</li><li>gfreecnt：可用的G（状态为 Gdead）。</li></ul><h3 id="P的状态"><a href="#P的状态" class="headerlink" title="P的状态"></a>P的状态</h3><blockquote><p>_Pidle    0    刚刚被分配，还没有进行进行初始化。<br>_Prunning    1    当 M 与 P 绑定调用 acquirep 时，P 的状态会改变为 _Prunning。<br>_Psyscall    2    正在执行系统调用。<br>_Pgcstop    3    暂停运行，此时系统正在进行 GC，直至 GC 结束后才会转变到下一个状态阶段。<br>_Pdead    4    废弃，不再使用。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> runtime </tag>
            
            <tag> scheduler </tag>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang调度模型(一)</title>
      <link href="2020/06/13/golang-scheduler/"/>
      <url>2020/06/13/golang-scheduler/</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ol><li>golang的调度是自己实现的,非依靠操作系统的抢占式模型.<br>是协作式调度,只有当正在运行的G被阻塞或者运行结束时,别的G才会被调度.</li><li>runtime.NumCPU是最大的并行数.</li><li>只有当正在运行的Goroutine被阻塞或者运行结束时,别的Goroutine才会被调度.常见的阻塞有:<blockquote><p>阻塞的系统调用方式，比如文件或网络操作<br>垃圾自动回收  </p></blockquote></li></ol><hr><h1 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h1><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><ol><li>G用于表示Goroutine及它所包含的当前运行的栈和状态信息.</li><li>G中保存的信息可以执行或恢复执行。</li></ol><h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><ol><li>M是OS线程的抽象,是物理存在的.</li><li>M只有和P绑定之后,才可以执行G代码.</li><li>M本身也不会保存G的状态,在需要任务切换时,M会将堆栈状态保存回G中,根据G中的信息恢复执行.</li></ol><h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><ol><li>P记录了G和M的相关信息,P需要调度M来让M执行G的代码.</li><li>在P中包含了本地可运行的Goroutine队列.</li><li>当一个新的G被创建,它会被追加在相应P队列的末尾,以保证最终会被执行。</li><li>当P没有可运行的Goroutine处理时,它会随机从其他P的Goroutines队列末尾取一半G用于自己消费(steal机制).</li><li>当P没有可运行的Goroutine处理时,也会有一定几率执行全局队列里的G<blockquote><pre><code>func main() {    var result int    processors := runtime.GOMAXPROCS(0)      for i := 0; i &lt; processors; i++ {        go func() {            for {                  result++                  //time.Sleep(time.Second)//加上这句,造成调度,就会运行结束.                }        }()    }    time.Sleep(time.Second)       //wait for go function to increment the value.    fmt.Println(&quot;result =&quot;, result)}</code></pre><p>这段代码最后的打印结果永远得不到输出<br>因为最大的并发数为GOMAXPROCS,每个goroutine都占用一个M,每个M又都占用一个P,<br>这段代码里的G又不会阻塞,所以调度器不会运行其它的goroutine,这就造成主goroutine永远不会被继续运行下去.　</p></blockquote></li></ol><hr><h1 id="自旋线程"><a href="#自旋线程" class="headerlink" title="自旋线程"></a>自旋线程</h1><ol><li>M进入了一种循环查找可运行G的状态.并不是所有的没有G的M都进入自旋,</li><li>当正在自旋的M个数的2倍&gt;=正在忙的p的个数时，不让该M进入自旋状态.</li><li>自旋需要消耗CPU的,如果已经有不少的P处于忙时,应该尽量让P去占用CPU资源,而不是为了查找G而浪费CPU.</li><li>如果一个M找不到G,又没有进入自旋状态,那么会休眠该M,并且会将P和M解绑.</li><li>新建一个goroutine或者有个goroutine准备好时,会唤醒M或者新建M.  </li></ol><hr><h1 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h1><h2 id="非channel通信造成"><a href="#非channel通信造成" class="headerlink" title="非channel通信造成"></a>非channel通信造成</h2><ol><li>当M准备执行Goroutine时,首选需要关联一个P,然后从P的队列中取出一个G来执行.</li><li>如果G中执行的代码使M发生阻塞,那么M将会一直阻塞,直到系统调用返回,阻塞状态的M会与P解绑.</li><li>此时全局空闲M队列的另一个M会被唤醒,这样做也是为了保证其他G不会因为缺少M而被阻塞执行.</li><li>当阻塞的调用返回时,先前阻塞的M会尝试去偷其它线程的P来继续执行,如果没有取得,就将G放到全局的G队列中.之后进入休眠.</li></ol><h2 id="channel通信造成"><a href="#channel通信造成" class="headerlink" title="channel通信造成"></a>channel通信造成</h2><ol><li>G的状态会被设置为等待,M会继续执行别的Goroutine.</li><li>当G重新变成可运行状态时,等待别的M去执行.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> runtime </tag>
            
            <tag> scheduler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang slice注意事项</title>
      <link href="2020/06/12/golang-slice/"/>
      <url>2020/06/12/golang-slice/</url>
      
        <content type="html"><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><pre><code>//newSlice和oldSlice指向同一个底层数组newSlice := oldSlice[0:cap(oldSlice)]if fmt.Sprintf(&quot;%p&quot;,&amp;newSlice[0]) == fmt.Sprintf(&quot;%p&quot;,&amp;oldSlice[0]){    fmt.Printf(&quot;这一句必然会执行&quot;)}</code></pre><h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><blockquote><p>采用append实现,当容量不够时会自动扩容,自动扩容的尺寸为append之前容量的2倍,不推荐此方法.</p></blockquote><pre><code>oldSlice := []int{0,1,2}fmt.Print(cap(oldSlice))//3newSlice := append(oldSlice,3)fmt.Print(cap(newSlice))//6if fmt.Sprintf(&quot;%p&quot;,&amp;newSlice[0]) == fmt.Sprintf(&quot;%p&quot;,&amp;oldSlice[0]){    fmt.Printf(&quot;这一句不会执行&quot;)}</code></pre><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><blockquote><p>采用copy实现,内存占用少,推荐此方法.</p></blockquote><pre><code>oldSlice := []int{0,1,2}newSlice := make([]int,3,4)copy(newSlice,oldSlice)newSlice[3] = 3// or newSlice = append(newSlice,3)fmt.Print(cap(newSlice))//4if fmt.Sprintf(&quot;%p&quot;,&amp;newSlice[0]) == fmt.Sprintf(&quot;%p&quot;,&amp;oldSlice[0]){    fmt.Printf(&quot;这一句不会执行&quot;)}</code></pre><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>因为重新切分的切片和原切片引用同一个数组,所以当指需要原切片一小部分数据时,最好复制这一小部分数据,否则内存中将保存大量的数据.<pre><code>var digitRegexp = regexp.MustCompile(&quot;[0-9]+&quot;)func FindDigits(filename string) []byte {  b, _ := ioutil.ReadFile(filename)  //只需要一小部分数据,但是却保存了一个文件的切片,  //因为需要的数据是重新切分的切片,和原数据应用的相同的底层数组.  return digitRegexp.Find(b)}func CopyDigits(filename string) []byte {  b, _ := ioutil.ReadFile(filename)  b = digitRegexp.Find(b)  c := make([]byte, len(b))  //用新数据代替了原数据,函数返回后原数据就会被销毁,不占用内存.  copy(c, b)  return c}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo可恢复部署(github pages)</title>
      <link href="2020/06/12/hexo-deploy/"/>
      <url>2020/06/12/hexo-deploy/</url>
      
        <content type="html"><![CDATA[<ul><li>新建远程master分支,本地无需新建.</li><li>本地新建creator分支</li><li>忽略页面生成文件夹(默认为public)</li><li>手动推送creator分支,这样换设备就可以继续编写.</li><li>一键部署设置为master分支</li></ul>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> deploy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang接口类型断言</title>
      <link href="2020/06/12/golang-interface-assert/"/>
      <url>2020/06/12/golang-interface-assert/</url>
      
        <content type="html"><![CDATA[<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>要弄清接口断言,必须先了解接口的静态类型和动态类型.</p><ul><li>静态类型:是变量声明的时候的声明类型.</li><li>动态类型(接口特有):运行时赋值给这个变量的具体的值的类型,值为nil的时候没有动态类型.<pre><code>type T stringvar x interface{} // x为零值nil,静态类型为interface{}var v *T // v为零值nil,静态类型为*Tx = 42 // x的值为42,动态类型为int,静态类型为interface{}x = v // x的值为nil,静态类型为interface{},没有动态类型,因为指为nilt := T(&quot;abc&quot;)x = &amp;t// x的值为abc,静态类型为interface{},动态类型为*T</code></pre><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><pre><code>n,ok := x.(T)</code></pre><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2></li><li>x必须是接口类型,如果不是可以用interface{}(x)来强转</li><li>如果T是接口且x已经实现了这个接口,那么n就是x相等的静态类型为T,动态类型为x同类型的值</li><li>如果T是结构体类型,那么n就会是T类型的变量,不会继承x的任何方法和属性</li><li>在需要调用动态类型的方法时,需要显示的做类型断言,不然编译器不知道运行时的类型,会报错(比如形参是空接口,实参是其它类型的时候)</li><li>当形参是空接口,实参是函数名的时候,是无法直接调用这个实参函数的,需要做如下调用<pre><code>type FuncType func(s string) intfunc PrintFunc(s string) int{  fmt.Println(s)  return 1}func JudgeFuncType(v interface{}){  if _func, ok := v.(FuncType); ok{      _func(&quot;hello&quot;)  }}func main() {  JudgeFuncType(FuncType(PrintFunc))}</code></pre><h1 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h1><h2 id="签名-1"><a href="#签名-1" class="headerlink" title="签名"></a>签名</h2><pre><code>x.(type)</code></pre><h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2></li><li>x必须是接口类型,如果不是可以用interface{}(x)来强转</li><li>只能和switch语句结合使用</li><li>返回实现的接口类型<pre><code>type I1 interface {  test()}type I2 interface {  test()}type T struct {  a int}func (i *T) test() {}func main() {  var i *T  i = &amp;T{a:1}  switch interface{}(i).(type) {  case I1:      fmt.Println(&quot;a&quot;)      break  case I2:      fmt.Println(&quot;b&quot;)      break  }}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang异常处理</title>
      <link href="2020/06/11/golang-panic/"/>
      <url>2020/06/11/golang-panic/</url>
      
        <content type="html"><![CDATA[<ul><li>可以在不希望程序继续运行的前提下使用异常</li><li>异常通过panic关键字或者意料之外的空指针等错误触发</li><li>程序一旦出现异常,会沿着调用栈向上逐个执行defer函数,直到最顶层.如果异常被捕获,那么会继续执行后面的语句.<pre><code>func funcA() error {  defer func() {      fmt.Println(&quot;ffffff\n&quot;)//执行  }()  return funcB()}func funcB() error {  panic(&quot;foo&quot;)  return errors.New(&quot;success&quot;)//这句不会执行}func test() {  defer func() {      if p := recover(); p != nil {          //此处捕获了异常          fmt.Printf(&quot;panic recover! p: %v\n&quot;, p)      }  }()  err := funcA()  //下面的语句不会执行  fmt.Printf(&quot;err is %v\n&quot;, err)}func main() {  test()  fmt.Printf(&quot;ddddd\n&quot;)//异常被捕获,这句就会执行.如果没有捕获就不会执行.}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> panic </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
