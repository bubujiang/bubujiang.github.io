<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>golang异常处理</title>
      <link href="/2020/06/11/golang-panic/"/>
      <url>/2020/06/11/golang-panic/</url>
      
        <content type="html"><![CDATA[<ul><li>可以在不希望程序继续运行的前提下使用异常</li><li>异常通过panic关键字或者意料之外的空指针等错误触发</li><li>程序一旦出现异常,会沿着调用栈向上逐个执行defer函数,直到最顶层.如果异常被捕获,那么会继续执行后面的语句.<pre><code>func funcA() error {  defer func() {      fmt.Println(&quot;ffffff\n&quot;)//执行  }()  return funcB()}func funcB() error {  panic(&quot;foo&quot;)  return errors.New(&quot;success&quot;)//这句不会执行}func test() {  defer func() {      if p := recover(); p != nil {          //此处捕获了异常          fmt.Printf(&quot;panic recover! p: %v\n&quot;, p)      }  }()  err := funcA()  //下面的语句不会执行  fmt.Printf(&quot;err is %v\n&quot;, err)}func main() {  test()  fmt.Printf(&quot;ddddd\n&quot;)//异常被捕获,这句就会执行.如果没有捕获就不会执行.}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
